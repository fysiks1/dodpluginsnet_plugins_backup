/*=================================================================================================
Syn's Nade Exploit Fix v1.002

This plugin is a spawn off of my dod_avalanche and dod_purple nade exploit fix plugins. This is
designed to be used with any map. All you need is a defintion file for a particular map. You can
also create your own or modify existing ones with the built in editor. The reason I made a universal
plugin for all maps is simple. Less to deal with. It would be a redunant to have to get different 
plugins to cover multiple maps. It also creates less mess on the dodplugins.net forums. XD

Currently comes with the following definitions:

dod_avalanche
dod_purple

===========================
v1.002 Changes
===========================
- Fixed non working player blocks.

===========================
v1.001 Changes
===========================
- Added missing admin flag check for console commands. Allowed anyone to use the editor! o.O
- Per request, added menu to access all console commands via menu.

===========================
Features & Notes
===========================
- Deflects nades from marked exploit locations on maps. Can block Allied, Axis, or all grenades.

- Blocks can be set to deflect players instead of nades on either or both teams as well. This is
good for spawn protection or anywhere you don't want players getting to.

- Built in editor for creating and editing your own custom blocks.

- Supports as many maps as you want.

- Each map definition file supports up to a maximum of 64 blocks.

- Want to have a map fixed? Let me know and I'll create a definition file for it or you can use the
built in editor to make your own!

- Credit goes out to the following people for helping me test, improve the original plugin to this
final refined, unified plugin and provide exploit locations for dod_avalance:
| Tank | Diamond-Optic | OnEHiTwOnDeR | Dr.G |

- Block locations whose vector is 0.0 / 0.0 / 0.0 (X/Y/Z) are ignored. The chances of placing a 
block at these coordinates are very slim but just incase I'm mentioning it.

- Unlike my previous dod_avalanche nade exploit fix map, I have not added an Axis player block into
Allied appartments from the penguin room. You can add it if you want.

===========================
Editor Mode
===========================
Because this is a more in depth function of the plugin, it gets it's own section. I've tried to
make it so creating your own block points are as less of a pita as possible. 

[> Setting up <]
- First you are going to join sectators and turn on the editor by typing: nade_exploit_editor
into your console. This toggles the editor on and off and anytime the map changes or the server 
restarts, it will always default off. Once you have enabled editor mode (console will show a message
to this effect) you can begin placing your blocks.

[> Keys <]
Attack - Place a new or select a highlighted block location for editing.

Attack2 - Cycle's through a selected entity's block modes, nade/allied/axis/all/remove.

Jump - Increment block location size.

Duck - Decrement block location size.

Turn Left - Rotate deflection direction to the left. This is not strafe left.

Turn Right - Rotate deflection direction to the right. This is not strafe right.

Run - Delete block location when editing it.

Use - This will instantly warp you back to the last spot you were editing from so you can check your
blocks quicker after spawing instead of walking all the way back. This location is saved only 
temporarily and does not save between map changes.

If you don't know the binds for these keys, here they are in the same order:

+attack
+attack2
+jump
+duck
+turnleft
+turnright
+run
+use

If you don't know what to do and don't know how to bind keys this example will help. Let's say you
want to bind cancel to your I key. You would go into the console and type:

bind i +cancel

So by looking at that you can see first we are using the bind command, then the first argument is
the key you want, I in this case, and the last part is the action command we are binding to the I
key. It's really simple. You can do this with any of your keys and any command. 

[> Working with blocks <]
This editor takes a simple approach to editing locations. All you have to do is aim where you want
the block to go and press your primary attack button. To make things even easier, there is a
temporary placement rabbit model for reference. Where this temp model is, is where your block will
be. The new block is also represented with a rabbit model. After placing a block, make sure you are
aiming at it. You will know your on it because you will see a white highlight box around it and an 
implosion effect. The implosion effect is a general representation of the block radius, that is,
the range at which you want to cover for blocking something. So now that you have your new block
highlighted press your primary attack again. This time the rabbit will turn red and the
highlight box will dissapear indicating that this block locations is currently being edited. You can
move around the map and place it in another location or you can change it's block type. There are 
6 block types you can choose from. These are Allied nades, Axis nades, all nades, Allied players, 
Axis players or all players. To cycle through each block type, have your block location bunny 
glowing red and press your secondary fire button. It will take you through all the modes. Also, if 
you want to delete a block location, have it in the red and hit your run key. This will remove it 
completely. Now on to the deflection. Setting this up is just as easy. Look at the way the rabbit
model is facing. He is pointing in the direction which objects will be deflected in. You can rotate 
the deflection angle with your turn left, and turn right keys. Generally you want to always deflect
away in the opposite direction of where something shouldn't go. All that is left now is the radius 
of the deflection. The radius is how big of an area you want to cover. Keep in mind that this radius
is the shape of a sphere. After playing around and setting up your block locations, test them out.
To make things easier after you spawn, press your use key and it will take you to the location of
the last block you edited. Once you are satisfied, go into the console and type: nade_exploit_save 
and it will save all of your current work to a file for the corresponding map your on. You can then 
exit editor mode by typing: nade_exploit_editor into the console again. This will resume normal 
operation. There is also a menu to access all console commands and can be gotten to by typing: 
nade_exploit_menu in console.

[> Additional info <]
- Remember that depending on the location you may need a few smaller radius block locations to cover
an area while others will suffice with a larger single block. Too big of a radius and it could block
parts of the map you don't want blocked and too small could lead to gaps that aren't fully covered. 

- If you need to start over to the last time you saved, just type: nade_exploit_load into the 
console.

- Using the console command: nade_exploit_wipe will completely wipe all block data from memory if 
you want to start all over. This does not wipe a saved map file though.
.
===========================
Console Commands:
===========================
nade_exploit_editor
- Toggles editor mode on or off for creating/editing exploit definition files.

nade_exploit_status
- Displays info in the console as to the status of the plugin such as the total exploit blocks
running or any errors the plugin encountered.

nade_exploit_save
- Will attempt to save the current exploit definition data to the map's corresponding file. This
process can take a few seconds to complete.

nade_exploit_load
- Will attempt a load or reload of the current map's exploit definition file if available.

nade_exploit_wipe
- Use this to completely start over with no block locations. Use this with nade_exploit_save to
clean the map definition file as well.

nade_exploit_menu
- Allows access to all the console commands via manu.

===========================
CVARs
===========================
nade_exploit_fix | 0 = off | 1 = on
- Enables or disables the Map Exploit Fix plugin. Default on.

nade_exploit_scan_time | x.x
- Allows changing the delay between every scan. This will let you adjust the plugin's CPU usage.
While it doesn't take alot of work to check these locations, you might have a slower server or wish
to optimize your server if you have lots of plugins running. The higher the number, the more time
there will between each global check but if it's too high, you run the risk of a blockee getting
past a block location. For the most part you want to keep this under 1 second. You can enter an 
integer or real number here. For example, a value of one would just be 1 second and a value of 1.5
would be 1 and a 1/2 seconds. Also, this only is for nade block locations. Players have to be
checked much faster in prethink. Default 0.5.

===========================
Installation
===========================
- Compile the .sma file | An online compiler can be found here:
  http:www.amxmodx.org/webcompiler.cgi
- Copy the compiled .amxx file into your addons\amxmodx\plugins folder
- Add the name of the compiled .amxx to the bottom of your addons\amxmodx\configs\plugins.ini
- Copy the desired map definition files to a new folder named nade_exploits inside of your amxmodx
config folder. For example most people's setups would look like this:
addons\amxmodx\configs\nade_exploits
- Change the map or restart your server to start using the plugin!

===========================
Support
===========================
Visit the AMXMODX Plugins section of the forums @ 
http:www.dodplugins.net or http:www.rivurs.com

===========================
License
===========================
Syn's Nade Exploit Fix
Copyright (C) 2012 Synthetic

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

=================================================================================================*/

#include <amxmodx>
#include <amxmisc>
#include <fakemeta>

// =================================================================================================
// Declare global variables and values
// =================================================================================================

// User adjustable variables
new Float:placement_model_rgb[3] = { 0.0,255.0,0.0 } // Sets the glow effect on the block location model.
new Float:placement_model_rgb_edit[3] = { 255.0,0.0,0.0 } // Sets the glow effect on the block location model when editing

// You probably don't want to mess with any of the ones below XD
new pntr_enable_fix
new pntr_scan_time

new Float:exploit_locations[64][3] // Holds block location vectors
new Float:vector_angle[64][3] // Holds block location deflection angle
new block_type[64] // Holds the type of block
new Float:exploit_sizes[64] // Holds the size of the block
new block_type_names[6][] = { "Allied Grenade","Axis Grenade","All Grenades","Allied Player","Axis Player","All Players" } // Stores the block types by name for when informing player

new nil // Used to store return values that are not needed
new Float:nade_origin[3] // Used to temporarily hold nade positional vector for checking against block locations
new total_blocks_player // Holds the total player blocks
new total_blocks_nade // Holds the total nade blocks
new total_blocks // Holds the total block locations in use for the current map
new block_info_switch // Switch used to display info for the currently selected block location once per selection
new block_info_id_old // Used with the switch above
new editor_entity_id[64] // Holds entity ID's of all created bunnies in editing mode for later removal
new status // Holds status flags used to report plugin's status
new block_selected // Keeps track of currently selected block location
new button_delay // Delay counter for input switches
new button_ok // Holds input allow or deny state
new editor_ent_id // Holds entity id of the block location placement bunny for later removal when needed
new editor_ent_created // Stores whether the block location placement bunny is removed or exists
new editor_ent_switch // Switch used to only allow one block locatin placement bunny at a time
new editing // Keeps track if editing a block location or not
new edit_ent_id_holder // Stores currently editing block location enitity ID
new edit_ent_cnt_holder // Stores currently editing block location counter to access correct location in blocking data arrays
new editor_enable // Keeps track of whether editor is enabled or not
new Float:edit_origin[3] = { 0.0,0.0,0.0 } // Holds the origin of where you last edited a block for warping back
new class_name[199] // Used to store class name when looking for aim at block locations
new Float:default_vector_angle[3] = { 0.0,0.0,0.0 } // Default deflection direction for new block locations
new Float:player_vec_angle[3] // Holds player's aim vector
new Float:player_origin[3] // Holds player's vector
new Float:temp_aim_vector[3] // Used to store player's vector angle (aim direciton)
new Float:final_aim_vector[3] // Holds final vector of where a player is aiming
new Float:lowest_distance = 99999.9 // Use to calculate the closest block location when aiming
new Float:distance // Holds distance value when check block locations agains nades/players
new temp_map_name[32] // Holds the map name when reading/writing definition files
new def_name[128] // Holds final definition file name and full path to directory
new def_dir[96] // Holds combined configs directory and custom directory for definition files
new config_dir[64] // Holds current config directory
new angle_conversion[8] = { 0,45,90,135,180,225,270,315 }
new Float:deflection_conversion_x[8] = { 0.0,200.0,200.0,200.0,0.0,-200.0,-200.0,-200.0 }
new Float:deflection_conversion_y[8] = { -200.0,-200.0,0.0,200.0,200.0,200.0,0.0,-200.0 }
new nade_exploit_menu // Keeps track of menu id

// =================================================================================================
// Precache resources
// =================================================================================================
public plugin_precache() {
	engfunc(EngFunc_PrecacheModel,"models/mapmodels/bunny.mdl")
}

// =================================================================================================
// Plugin Init
// =================================================================================================
public plugin_init() {
	
	register_plugin("Syn's Nade Exploit Fix","1.002","Synthetic")
	register_cvar("Version 1.002 by Synthetic", "Syns_Nade_Exploit_Fix",FCVAR_SERVER|FCVAR_SPONLY)
	
	pntr_enable_fix = register_cvar("nade_exploit_fix","1")
	pntr_scan_time = register_cvar("nade_exploit_scan_time","0.5")
	
	register_concmd("nade_exploit_editor","func_editor",ADMIN_RCON,"Enables editing mode for creating exploit blocks.")
	register_concmd("nade_exploit_status","func_exploit_status",ADMIN_RCON,"Displays the current status of the nade exploit plugin.")
	register_concmd("nade_exploit_save","func_write_exploit_def",ADMIN_RCON,"Saves exploit data to corresponding map file.")
	register_concmd("nade_exploit_load","func_load_map_def",ADMIN_RCON,"Reload exploit definition file if available.")
	register_concmd("nade_exploit_wipe","func_wipe_arrays",ADMIN_RCON,"Wipes all block locations from memory.")
	register_concmd("nade_exploit_menu","func_nade_menu",ADMIN_RCON,"Shows menu.")
	
	get_mapname(temp_map_name,31)
	get_configsdir(config_dir,63)
	if(get_pcvar_num(pntr_enable_fix))
	{
		set_task(0.5,"func_load_map_def")
	}
	
	register_forward(FM_PlayerPreThink,"func_prethink")
}

// =================================================================================================
// Setup menu
// =================================================================================================
public func_nade_menu(id,level,cid) {
	if(!cmd_access(id,level,cid,1))
		return PLUGIN_HANDLED
	
	nade_exploit_menu = menu_create("Nade Exploit Menu","func_handle_menu")
	
	if(editor_enable)
	{
		menu_additem(nade_exploit_menu,"Disable editor", "1", 0)
	}
	else
	{
		menu_additem(nade_exploit_menu,"Enable editor","1",0)
	}

	menu_additem(nade_exploit_menu,"Save definition file","2",0)
	menu_additem(nade_exploit_menu,"Load definition file","3",0)
	menu_additem(nade_exploit_menu,"Wipe definition data","4",0)
	menu_additem(nade_exploit_menu,"View status","5",0)
	menu_setprop(nade_exploit_menu,MPROP_EXIT,MEXIT_ALL)
	menu_display(id,nade_exploit_menu,0)
	
	return PLUGIN_HANDLED
}

// =================================================================================================
// Handle menu
// =================================================================================================
public func_handle_menu(id,nade_exploit_menu,item) {
	if(item == MENU_EXIT)
	{
		menu_destroy(nade_exploit_menu)
		return PLUGIN_HANDLED
	}
	
	new data[6]
	new null[1]
	new access,callback
	menu_item_getinfo(nade_exploit_menu,item,access,data,5,null,0,callback)
	new key = str_to_num(data)
	
	switch(key){
		case 1:{
			client_cmd(id,"nade_exploit_editor")
		}
		case 2:{
			client_cmd(id,"nade_exploit_save")
		}
		case 3:{
			client_cmd(id,"nade_exploit_load")
		}
		case 4:{
			client_cmd(id,"nade_exploit_wipe")
		}
		case 5:{
			client_cmd(id,"nade_exploit_status")
		}
	}
	menu_destroy(nade_exploit_menu)
	return PLUGIN_HANDLED
}

// =================================================================================================
// Handle editor functions
// =================================================================================================
public func_prethink(id) {
	total_blocks = total_blocks_player + total_blocks_nade
	if(editor_enable)
	{
		new i
		new lowest_distance_ent
		new lowest_ent_counter
		new bypass_location
		lowest_distance = 99999.9
		
		distance = get_user_aiming (id,nil,nil)
		pev(id,pev_origin,player_origin)
		pev(id,pev_v_angle,player_vec_angle)
			
		// Calculate the end vector of where a player is aiming because trace lines are too damn slow! XD
		angle_vector(player_vec_angle,ANGLEVECTOR_FORWARD,temp_aim_vector)
		final_aim_vector[0] = temp_aim_vector[0] * distance + player_origin[0]
		final_aim_vector[1] = temp_aim_vector[1] * distance + player_origin[1]
		final_aim_vector[2] = temp_aim_vector[2] * distance + player_origin[2]
				
		// Find closest exploit location by aim
		if(!editing)
		{
			for(i=0;i<64;++i)
			{
				// Ignore empty definition locations
				bypass_location = 0
				if(exploit_locations[i][0] == 0.0 && exploit_locations[i][1] == 0.0 && exploit_locations[i][2] == 0.0)
				{
					bypass_location = 1
				}
				if(!bypass_location)
				{
					if(get_distance_f(exploit_locations[i],final_aim_vector) < lowest_distance)
					{
						lowest_distance = get_distance_f(exploit_locations[i],final_aim_vector)
						lowest_distance_ent = editor_entity_id[i]
						lowest_ent_counter = i
					}
					else
					{
						editor_ent_switch = 0
					}
				}
			}
			
			// Draw box around closest exploit location by aim and show general blocking distance with implosion effect
			if(lowest_distance_ent > 0 && pev_valid(lowest_distance_ent) && lowest_distance < 20  && !is_user_alive(id))
			{
				pev(lowest_distance_ent,pev_classname,class_name,198)
				if(equal(class_name,"bunny"))
				{
					func_show_bb(lowest_distance_ent,lowest_ent_counter,1)
					if(!block_info_switch && block_info_id_old != lowest_distance_ent)
					{
						client_print(0,print_chat,"[Nade Exploit] Block location index: %i | Size: %f | Type: %s",lowest_ent_counter,exploit_sizes[lowest_ent_counter],block_type_names[block_type[lowest_ent_counter]])
						new c
						new Float:final_deflection_angle[3]
						for(c=0;c<8;++c)
						{
							if(vector_angle[lowest_ent_counter][1] == angle_conversion[c])
							{
								final_deflection_angle[0] = deflection_conversion_x[c]
								final_deflection_angle[1] = deflection_conversion_y[c]
							}

						}
						client_print(0,print_chat,"[Nade Exploit] Direction | Y: %f",vector_angle[lowest_ent_counter][1])
						client_print(0,print_chat,"[Nade Exploit] Deflection direction | X: %f | Y: %f",final_deflection_angle[0],final_deflection_angle[1])
					
						block_info_switch = 1
						block_info_id_old = lowest_distance_ent
					}
					block_selected = lowest_distance_ent
					editor_ent_switch = 1
					editor_ent_created = 0
					if(pev_valid(editor_ent_id))
						engfunc(EngFunc_RemoveEntity,editor_ent_id)
				}
				else
				{
					
				}
			}
			else
			{
				block_info_switch = 0
				block_info_id_old = 0
				block_selected = -1
			}
			
			// Show placement model for new block location and update it's origin
			if(!editor_ent_created && !editor_ent_switch)
			{
				func_create_entity(final_aim_vector,default_vector_angle,0,1) // Draw editor placement bunny
				editor_ent_created = 1
			}
			if(pev_valid(editor_ent_id))
			{
				set_pev(editor_ent_id,pev_origin,final_aim_vector)
			}
		
		}
		
		// Reset input delay - Since IN_ buttons automatically cycle when pressed, we must create a switch to prevent actions continually running
		if(button_delay == 55)
		{
			button_ok = 1
		}
		if(button_ok == 1  && !is_user_alive(id))
		{
			// Edit or create new on primary attack
			if(pev(id,pev_button) & IN_ATTACK && pev(id,pev_oldbuttons) & IN_ATTACK)
			{
				if(!editing && block_selected >= 0 )
				{
					pev(id,pev_origin,edit_origin)
					editing = 1
					edit_ent_id_holder = block_selected
					edit_ent_cnt_holder = lowest_ent_counter
				}
				else
				{
					editing = 0
				}
				
				// Create new block location
				if(block_selected < 0)
				{
					// Make sure we don't go over 64 blocks
					if(total_blocks > 63)
					{
						client_print(0,print_chat,"[Nade Exploit] Maximum block locations have been reached!")
						return FMRES_IGNORED
					}
					
					// Add new block location into storage array
					for(i=0;i<64;++i)
					{
						// Ignore empty definition locations
						if(exploit_locations[i][0] == 0.0 && exploit_locations[i][1] == 0.0 && exploit_locations[i][2] == 0.0)
						{			
							total_blocks++
							block_type[i] = 0
							exploit_sizes[i] = 20.0
							exploit_locations[i][0] = final_aim_vector[0] + 10
							exploit_locations[i][1] = final_aim_vector[1] + 10
							exploit_locations[i][2] = final_aim_vector[2] + 10
							vector_angle[i][0] = default_vector_angle[0]
							vector_angle[i][1] = default_vector_angle[1]
							vector_angle[i][2] = default_vector_angle[2]
							func_create_entity(final_aim_vector,default_vector_angle,i,0)
							break
						}
					}
				}
			}

			// Create/cycle mode for a block location
			if(pev(id,pev_button) & IN_ATTACK2 && pev(id,pev_oldbuttons) & IN_ATTACK2)
			{
				if(editing)
				{
					//cycle_block_type = edit_block_holder
					block_type[edit_ent_cnt_holder]++
					if(block_type[edit_ent_cnt_holder] == 6)
					{
						block_type[edit_ent_cnt_holder] = 0
					}
					if(block_type[edit_ent_cnt_holder] == 0)
					{
						client_print(0,print_chat,"[Nade Exploit] Edited index: %i | Size: %f | Type: %s",edit_ent_cnt_holder + 1,exploit_sizes[edit_ent_cnt_holder],block_type_names[block_type[edit_ent_cnt_holder]])
					}
					if(block_type[edit_ent_cnt_holder] == 1)
					{
						client_print(0,print_chat,"[Nade Exploit] Edited index: %i | Size: %f | Type: %s",edit_ent_cnt_holder + 1,exploit_sizes[edit_ent_cnt_holder],block_type_names[block_type[edit_ent_cnt_holder]])
					}
					if(block_type[edit_ent_cnt_holder] == 2)
					{
						client_print(0,print_chat,"[Nade Exploit] Edited index: %i | Size: %f | Type: %s",edit_ent_cnt_holder + 1,exploit_sizes[edit_ent_cnt_holder],block_type_names[block_type[edit_ent_cnt_holder]])
					}
					if(block_type[edit_ent_cnt_holder] == 3)
					{
						client_print(0,print_chat,"[Nade Exploit] Edited index: %i | Size: %f | Type: %s",edit_ent_cnt_holder + 1,exploit_sizes[edit_ent_cnt_holder],block_type_names[block_type[edit_ent_cnt_holder]])
					}
					if(block_type[edit_ent_cnt_holder] == 4)
					{
						client_print(0,print_chat,"[Nade Exploit] Edited index: %i | Size: %f | Type: %s",edit_ent_cnt_holder + 1,exploit_sizes[edit_ent_cnt_holder],block_type_names[block_type[edit_ent_cnt_holder]])
					}
					if(block_type[edit_ent_cnt_holder] == 5)
					{
						client_print(0,print_chat,"[Nade Exploit] Edited index: %i | Size: %f | Type: %s",edit_ent_cnt_holder + 1,exploit_sizes[edit_ent_cnt_holder],block_type_names[block_type[edit_ent_cnt_holder]])
					}
				}
			}
			
			// Delete a selected block location
			if(pev(id,pev_button) & IN_RUN && pev(id,pev_oldbuttons) & IN_RUN)
			{
				if(editing)
				{
					engfunc(EngFunc_RemoveEntity,editor_entity_id[edit_ent_cnt_holder])
					exploit_locations[edit_ent_cnt_holder][0] = 0.0
					exploit_locations[edit_ent_cnt_holder][1] = 0.0
					exploit_locations[edit_ent_cnt_holder][2] = 0.0
					client_print(0,print_chat,"[Nade Exploit] Removed block location index: %i",edit_ent_cnt_holder + 1)
					editing = 0
				}
			}
			
			// Increment size of block location
			if(pev(id,pev_button) & IN_JUMP && pev(id,pev_oldbuttons) & IN_JUMP)
			{
				if(editing)
				{
					exploit_sizes[edit_ent_cnt_holder] = exploit_sizes[edit_ent_cnt_holder] + 5
					client_print(0,print_chat,"[Nade Exploit] Edited block location index: %i | Size: %f | Type: %s",edit_ent_cnt_holder + 1,exploit_sizes[edit_ent_cnt_holder],block_type_names[block_type[edit_ent_cnt_holder]])
				}
			}
			
			// Decrement size of block location
			if(pev(id,pev_button) & IN_DUCK && pev(id,pev_oldbuttons) & IN_DUCK)
			{
				if(editing)
				{
					exploit_sizes[edit_ent_cnt_holder] = exploit_sizes[edit_ent_cnt_holder] - 5
					client_print(0,print_chat,"[Nade Exploit] Edited block location index: %i | Size: %f | Type: %s",edit_ent_cnt_holder + 1,exploit_sizes[edit_ent_cnt_holder],block_type_names[block_type[edit_ent_cnt_holder]])
				}
			}
			
			// Change deflection angle to the left
			if(pev(id,pev_button) & IN_LEFT && pev(id,pev_oldbuttons) & IN_LEFT)
			{
				if(editing)
				{
					vector_angle[edit_ent_cnt_holder][1] = vector_angle[edit_ent_cnt_holder][1] + 45
					if(vector_angle[edit_ent_cnt_holder][1] >= 360.0)
					{
						vector_angle[edit_ent_cnt_holder][1] = 0.0
					}
					set_pev(edit_ent_id_holder,pev_angles,vector_angle[edit_ent_cnt_holder])
					client_print(0,print_chat,"[Nade Exploit] Edited block location index: %i | Size: %f | Type: %s",edit_ent_cnt_holder + 1,exploit_sizes[edit_ent_cnt_holder],block_type_names[block_type[edit_ent_cnt_holder]])
				}
			}
			
			// Change deflection angle to the right
			if(pev(id,pev_button) & IN_RIGHT && pev(id,pev_oldbuttons) & IN_RIGHT)
			{
				if(editing)
				{
					vector_angle[edit_ent_cnt_holder][1] = vector_angle[edit_ent_cnt_holder][1] - 45
					if(vector_angle[edit_ent_cnt_holder][1] < 0.0)
					{
						vector_angle[edit_ent_cnt_holder][1] = 315.0
					}
					set_pev(edit_ent_id_holder,pev_angles,vector_angle[edit_ent_cnt_holder])
					client_print(0,print_chat,"[Nade Exploit] Edited block location index: %i | Size: %f | Type: %s",edit_ent_cnt_holder + 1,exploit_sizes[edit_ent_cnt_holder],block_type_names[block_type[edit_ent_cnt_holder]])
				}
			}
		
			// Kill use of input and reset switch delay timer to starting point
			button_delay = 0
			button_ok = 0
		}
		
		// Warp to previous edit location
		if(pev(id,pev_button) & IN_USE && pev(id,pev_oldbuttons) & IN_USE)
		{
			set_pev(id,pev_origin,edit_origin)
			client_print(0,print_chat,"[Nade Exploit] Warping to last edit location!")
		}
		
		// Increment input delay counter
		if(button_delay < 55)
		{
			button_delay++
		}
		
		// Control and edit a block location if editing
		if(editing)
		{
			// Kill off placement block model
			if(pev_valid(editor_ent_id))
			{
				engfunc(EngFunc_RemoveEntity,editor_ent_id)
			}
				
			func_show_bb(edit_ent_id_holder,edit_ent_cnt_holder,0)
			set_pev(edit_ent_id_holder,pev_origin,final_aim_vector)
			set_pev(edit_ent_id_holder,pev_rendercolor,placement_model_rgb_edit)
			exploit_locations[edit_ent_cnt_holder][0] = final_aim_vector[0]
			exploit_locations[edit_ent_cnt_holder][1] = final_aim_vector[1]
			exploit_locations[edit_ent_cnt_holder][2] = final_aim_vector[2]
			
			// Block turn left and right so we can stay looking at what we are doing
			set_pev(id,pev_button,pev(id,pev_button) & ~IN_LEFT)
			set_pev(id,pev_button,pev(id,pev_button) & ~IN_RIGHT)
		}
		else
		{
			if(pev_valid(edit_ent_id_holder))
			{
				set_pev(edit_ent_id_holder,pev_rendercolor,placement_model_rgb)
			}
		}
	}
	
	// Player blocks must be handled faster
	if(get_pcvar_num(pntr_enable_fix))
	{
		new i,n,c
		new bypass_location
		new Float:final_deflection_angle[3]
		pev(id,pev_origin,player_origin)
		total_blocks_player = 0
		for(i=0;i<64;i++)
		{
			// Ignore empty definition locations
			bypass_location = 0
			if(exploit_locations[i][0] == 0.0 && exploit_locations[i][1] == 0.0 && exploit_locations[i][2] == 0.0)
			{
				bypass_location = 1
			}
			
			// Identify blockees invading block locations
			if(!bypass_location)
			{	
				// Check for allied players
				if(block_type[i] == 3)
				{
					total_blocks_player++
					for(n=0;n<64;n++)
					{
						distance = get_distance_f(player_origin,exploit_locations[n])
						if(distance < exploit_sizes[n] && pev(id,pev_team) == 1)
						{
							for(c=0;c<8;++c)
							{
								if(vector_angle[n][1] == angle_conversion[c])
								{
									final_deflection_angle[0] = deflection_conversion_x[c]
									final_deflection_angle[1] = deflection_conversion_y[c]
								}
							}
							set_pev(id,pev_velocity,final_deflection_angle)
						}
					}
				}
					
				// Check for axis players
				if(block_type[i] == 4)
				{
					total_blocks_player++
					for(n=0;n<64;n++)
					{
						distance = get_distance_f(player_origin,exploit_locations[n])
						if(distance < exploit_sizes[n] && pev(id,pev_team) == 2)
						{
							for(c=0;c<8;++c)
							{
								if(vector_angle[n][1] == angle_conversion[c])
								{
									final_deflection_angle[0] = deflection_conversion_x[c]
									final_deflection_angle[1] = deflection_conversion_y[c]
								}
							}
							set_pev(id,pev_velocity,final_deflection_angle)
						}
					}
				}
					
				// Check for all players
				if(block_type[i] == 5)
				{
					total_blocks_player++
					for(n=0;n<64;n++)
					{
						distance = get_distance_f(player_origin,exploit_locations[n])
						if(distance < exploit_sizes[n])
						{
							if(pev(id,pev_team) == 2 || pev(id,pev_team) == 1)
							{
								for(c=0;c<8;++c)
								{
									if(vector_angle[n][1] == angle_conversion[c])
									{
										final_deflection_angle[0] = deflection_conversion_x[c]
										final_deflection_angle[1] = deflection_conversion_y[c]
									}
								}
								set_pev(id,pev_velocity,final_deflection_angle)
							}
						}
					}
				}
			}
		}
	}
	return FMRES_HANDLED
}

// =================================================================================================
// Toggle editor on or off
// =================================================================================================
public func_editor(id,level,cid) {
	if(!cmd_access(id,level,cid,1))
		return PLUGIN_HANDLED
		
	// Make sure user is in spector mode
	if(!editor_enable && is_user_alive(id))
	{
		client_print(id,print_console,"[Nade Exploit] You must be in spectator mode to use the editor!")
		client_print(id,print_chat,"[Nade Exploit] You must be in spectator mode to use the editor!")
		return PLUGIN_HANDLED
	}
	
	new i
	new bypass_location
	
	// Show block locations with bunnies if editor mode is switched on
	if(!editor_enable)
	{
		client_print(id,print_console,"[Nade Exploit] Editor mode enabled. %i block(s) running.",total_blocks + 1)
		client_print(id,print_chat,"[Nade Exploit] Editor mode enabled. %i block(s) running.",total_blocks + 1)
		for(i=0;i<64;++i)
		{
			// Ignore empty definition locations
			bypass_location = 0
			if(exploit_locations[i][0] == 0.0 && exploit_locations[i][1] == 0.0 && exploit_locations[i][2] == 0.0)
			{
				bypass_location = 1
			}
			if(!bypass_location)
			{
				func_create_entity(exploit_locations[i],vector_angle[i],i,0)
			}
		}
		editor_enable = 1
	}
	else
	{
		// Disable editor
		client_print(id,print_console,"[Nade Exploit] Editor mode disabled!")
		client_print(id,print_chat,"[Nade Exploit] Editor mode disabled!")
		if(pev_valid(editor_ent_id))
		{
			engfunc(EngFunc_RemoveEntity,editor_ent_id)
			editor_ent_created = 0
			editor_ent_switch = 0
		}
		for(i=0;i<64;++i)
		{
			if(pev_valid(editor_entity_id[i]))
			{
				engfunc(EngFunc_RemoveEntity,editor_entity_id[i])
			}
		}
		editor_enable = 0
	}
	return PLUGIN_HANDLED
}

// =================================================================================================
// Wipe all block location data from arrays
// =================================================================================================
public func_wipe_arrays(id,level,cid) {
	if(!cmd_access(id,level,cid,1))
		return PLUGIN_HANDLED
		
	new i

	// Write zeros
	for(i=0;i<64;++i)
	{
		exploit_locations[i][0] = 0.0
		exploit_locations[i][1] = 0.0
		exploit_locations[i][2] = 0.0
		
		vector_angle[i][0] = 0.0
		vector_angle[i][1] = 0.0
		vector_angle[i][2] = 0.0
			
		exploit_sizes[i] = 0.0
		block_type[i] = 0
		
		total_blocks = 0
		
		// Remove editor block models
		if(pev_valid(editor_entity_id[i]))
		{
			engfunc(EngFunc_RemoveEntity,editor_entity_id[i])
		}
	}
	client_print(0,print_console,"[Nade Exploit] Block location data wiped!")
	client_print(0,print_chat,"[Nade Exploit] Block location data wiped!")
	
	return PLUGIN_HANDLED
}

// =================================================================================================
// Setup blocks
// =================================================================================================
public func_fix_exploits() {
	if(get_pcvar_num(pntr_enable_fix))
	{
		new i,c,ent
		new bypass_location
		new Float:final_deflection_angle[3]
		total_blocks_nade = 0
		
		for(i=0;i<64;i++)
		{
			// Ignore empty definition locations
			bypass_location = 0
			if(exploit_locations[i][0] == 0.0 && exploit_locations[i][1] == 0.0 && exploit_locations[i][2] == 0.0)
			{
				bypass_location = 1
			}
			
			// Identify blockees invading block locations
			if(!bypass_location)
			{	
				// Check for allied nades
				if(block_type[i] == 0)
				{
					total_blocks_nade++
					while((ent = engfunc(EngFunc_FindEntityByString,ent,"classname","grenade")) != 0)
					{
						pev(ent,pev_origin,nade_origin)
						distance = get_distance_f(nade_origin,exploit_locations[i])
						if(distance < exploit_sizes[i])
						{
							for(c=0;c<8;++c)
							{
								if(vector_angle[i][1] == angle_conversion[c])
								{
									final_deflection_angle[0] = deflection_conversion_x[c]
									final_deflection_angle[1] = deflection_conversion_y[c]
								}
							}
							set_pev(ent,pev_velocity,final_deflection_angle)
						}
					}
					while((ent = engfunc(EngFunc_FindEntityByString,ent,"classname","grenade1")) != 0)
					{
						pev(ent,pev_origin,nade_origin)
						distance = get_distance_f(nade_origin,exploit_locations[i])
						if(distance < exploit_sizes[i])
						{
							for(c=0;c<8;++c)
							{
								if(vector_angle[i][1] == angle_conversion[c])
								{
									final_deflection_angle[0] = deflection_conversion_x[c]
									final_deflection_angle[1] = deflection_conversion_y[c]
								}
							}
							set_pev(ent,pev_velocity,final_deflection_angle)
						}
					}
				}
				
				// Check for axis nades
				if(block_type[i] == 1)
				{
					total_blocks_nade++
					while((ent = engfunc(EngFunc_FindEntityByString,ent,"classname","grenade2")) != 0)
					{
						pev(ent,pev_origin,nade_origin)
						distance = get_distance_f(nade_origin,exploit_locations[i])
						if(distance < exploit_sizes[i])
						{
							for(c=0;c<8;++c)
							{
								if(vector_angle[i][1] == angle_conversion[c])
								{
									final_deflection_angle[0] = deflection_conversion_x[c]
									final_deflection_angle[1] = deflection_conversion_y[c]
								}
							}
							set_pev(ent,pev_velocity,final_deflection_angle)
						}
					}
				}
				
				// Check for all nades
				if(block_type[i] == 2)
				{
					total_blocks_nade++
					while((ent = engfunc(EngFunc_FindEntityByString,ent,"classname","grenade")) != 0)
					{
						pev(ent,pev_origin,nade_origin)
						distance = get_distance_f(nade_origin,exploit_locations[i])
						if(distance < exploit_sizes[i])
						{
							for(c=0;c<8;++c)
							{
								if(vector_angle[i][1] == angle_conversion[c])
								{
									final_deflection_angle[0] = deflection_conversion_x[c]
									final_deflection_angle[1] = deflection_conversion_y[c]
								}
							}
							set_pev(ent,pev_velocity,final_deflection_angle)
						}
					}
					while((ent = engfunc(EngFunc_FindEntityByString,ent,"classname","grenade1")) != 0)
					{
						pev(ent,pev_origin,nade_origin)
						distance = get_distance_f(nade_origin,exploit_locations[i])
						if(distance < exploit_sizes[i])
						{
							for(c=0;c<8;++c)
							{
								if(vector_angle[i][1] == angle_conversion[c])
								{
									final_deflection_angle[0] = deflection_conversion_x[c]
									final_deflection_angle[1] = deflection_conversion_y[c]
								}
							}
							set_pev(ent,pev_velocity,final_deflection_angle)
						}
					}
					while((ent = engfunc(EngFunc_FindEntityByString,ent,"classname","grenade2")) != 0)
					{
						pev(ent,pev_origin,nade_origin)
						distance = get_distance_f(nade_origin,exploit_locations[i])
						if(distance < exploit_sizes[i])
						{
							for(c=0;c<8;++c)
							{
								if(vector_angle[i][1] == angle_conversion[c])
								{
									final_deflection_angle[0] = deflection_conversion_x[c]
									final_deflection_angle[1] = deflection_conversion_y[c]
								}
							}
							set_pev(ent,pev_velocity,final_deflection_angle)
						}
					}
				}
			}
		}
	}
}

// =================================================================================================
// Check for and load map definition file if available
// =================================================================================================
public func_load_map_def(id,level,cid) {
	if(!cmd_access(id,level,cid,1))
		return PLUGIN_HANDLED
		
	if(get_pcvar_num(pntr_enable_fix))
	{
		format(def_dir,95,"%s/nade_exploits",config_dir)
		format(def_name,127,"%s/%s.edf",def_dir,temp_map_name)
		
		// Does an exploit definition file exist for this map? If so, load it!
		if(file_exists(def_name))
		{
			new i,temp_holder[8]
			new n = 3
			
			// Read definition data
			for(i=0;i<64;++i)
			{
				// Read exploit locations
				read_file(def_name,++n,temp_holder,7,nil)
				exploit_locations[i][0] = str_to_float(temp_holder)
				read_file(def_name,++n,temp_holder,7,nil)
				exploit_locations[i][1] = str_to_float(temp_holder)
				read_file(def_name,++n,temp_holder,7,nil)
				exploit_locations[i][2] = str_to_float(temp_holder)
				
				// Direction deflection angle	
				read_file(def_name,++n,temp_holder,7,nil)
				vector_angle[i][0] = str_to_float(temp_holder)
				read_file(def_name,++n,temp_holder,7,nil)
				vector_angle[i][1] = str_to_float(temp_holder)
				read_file(def_name,++n,temp_holder,7,nil)
				vector_angle[i][2] = str_to_float(temp_holder)
				
				// Read block size and type (0 = nade, 1 = player)
				read_file(def_name,++n,temp_holder,5,nil)
				exploit_sizes[i] = str_to_float(temp_holder)
				read_file(def_name,++n,temp_holder,1,nil)
				block_type[i] = str_to_num(temp_holder)
				++n
				
				// Remove all original block location entities
				if(pev_valid(editor_entity_id[i]))
				{
					engfunc(EngFunc_RemoveEntity,editor_entity_id[i])
				}
			}
			
			// Recreate editor bunnies if editor mode is on
			if(editor_enable)
			{
				new bypass_location
				for(i=0;i<64;++i)
				{
					// Ignore empty definition locations
					bypass_location = 0
					if(exploit_locations[i][0] == 0.0 && exploit_locations[i][1] == 0.0 && exploit_locations[i][2] == 0.0)
					{
						bypass_location = 1
					}
					if(!bypass_location)
					{
						func_create_entity(exploit_locations[i],vector_angle[i],i,0)
					}
				}
			}
			
			client_print(id,print_console,"[Nade Exploit] Loaded definition file: %s",def_name)
			client_print(id,print_chat,"[Nade Exploit] Loaded definition file: %s",def_name)
			status = 1
			
			// Kill off task if it's already running and start fresh
			if(task_exists(2000))
			{
				remove_task(2000)
			}
			set_task(get_pcvar_float(pntr_scan_time),"func_fix_exploits",2000,"",0,"b")
		}
		else
		{
			client_print(id,print_console,"[Nade Exploit] There was a problem loading the definition file: %s",def_name)
			client_print(id,print_chat,"[Nade Exploit] There was a problem loading the definition file: %s",def_name)
			status = 2
		}
	}
	return PLUGIN_HANDLED
}

// =================================================================================================
// Write definition file - If your reading this, always use the new file functions and not write_file XD
// =================================================================================================
public func_write_exploit_def(id,level,cid) {
	if(!cmd_access(id,level,cid,1))
		return PLUGIN_HANDLED
		
	// If editor mode isn't on, kill
	if(!editor_enable)
	{
		client_print(id,print_console,"[Nade Exploit] This feature can only be used in editor mode!")
		client_print(id,print_chat,"[Nade Exploit] This feature can only be used in editor mode!")
		return PLUGIN_HANDLED
	}
	
	format(def_dir,95,"%s/nade_exploits",config_dir)
	format(def_name,127,"%s/%s.edf",def_dir,temp_map_name)
	
	// Create definition file
	if(dir_exists(def_dir))
	{
		new i
		
		new file = fopen(def_name,"w")

		// Write header
		fprintf(file,"=================================================================================================^n")
		fprintf(file,"Synthetic's nade exploit definition file^n")
		fprintf(file,"=================================================================================================^n")
		
		// Write definition data
		for(i=0;i<64;++i)
		{
			// Write index
			fprintf(file,"Index: %i^n",i)
			
			// Write exploit location
			fprintf(file,"%f^n",exploit_locations[i][0])
			fprintf(file,"%f^n",exploit_locations[i][1])
			fprintf(file,"%f^n",exploit_locations[i][2])
			
			// Write directions
			fprintf(file,"%f^n",vector_angle[i][0])
			fprintf(file,"%f^n",vector_angle[i][1])
			fprintf(file,"%f^n",vector_angle[i][2])
			
			// Write block size and type
			fprintf(file,"%f^n",exploit_sizes[i])
			fprintf(file,"%i^n",block_type[i])
		}
		
		fclose(file)
		client_print(id,print_console,"[Nade Exploit] Created definition file: %s",def_name)
		client_print(id,print_chat,"[Nade Exploit] Created definition file: %s",def_name)
	}
	else
	{
		client_print(id,print_console,"[Nade Exploit] There was a problem loading the definition file: %s",def_name)
		client_print(id,print_chat,"[Nade Exploit] There was a problem loading the definition file: %s",def_name)
		
	}
	return PLUGIN_HANDLED
}

// =================================================================================================
// Create entity
// =================================================================================================
public func_create_entity(Float:temp_location[],Float:angles[],counter,type) {
	new entity_id
	new Float:size_min[3] = { -10.0,-10.0,-10.0 }
	new Float:size_max[3] = { 10.0,10.0,10.0 }
	
	// Create entity
	entity_id = engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"info_target"))
	
	// Proceed with setting entity values if entity successfully created
	if(entity_id)
	{
		// Set class name
		set_pev(entity_id,pev_classname,"bunny")
				
		// Set entity model
		engfunc(EngFunc_SetModel,entity_id,"models/mapmodels/bunny.mdl")
				
		// Set entity position
		engfunc(EngFunc_SetOrigin,entity_id,temp_location)
				
		// Set entity bb size
		engfunc(EngFunc_SetSize,entity_id,size_min,size_max)
				
		// Set the entity angles
		set_pev(entity_id,pev_angles,angles)
				
		// Make entity solid
		set_pev(entity_id,pev_solid,SOLID_NOT)
		
		// Set move type
		set_pev(entity_id,pev_movetype,MOVETYPE_FLY)
		
		// Make the model easier to see with a glow effect
		set_pev(entity_id,pev_renderfx,kRenderFxGlowShell)
		set_pev(entity_id,pev_rendercolor,placement_model_rgb)
		
		// Keep track of all created bunnies' entity IDs so we can remove them when the editor is turned off
		if(!type)
		{
			editor_entity_id[counter] = entity_id
		}
		else
		{
			editor_ent_id = entity_id
		}
	}
}

// =================================================================================================
// Draw box around entity and show general block radius with implosion effect
// =================================================================================================
public func_show_bb(ent_id,counter,mode) {
	new Float:mins[3],Float:maxs[3]
	new radius
	pev(ent_id,pev_absmin,mins)
	pev(ent_id,pev_absmax,maxs)
	radius = floatround(exploit_sizes[counter])  - 13
	if(mode)
	{
		// Box
		message_begin(MSG_BROADCAST,SVC_TEMPENTITY)
		write_byte(31)
		write_coord(floatround(mins[0]))
		write_coord(floatround(mins[1]))
		write_coord(floatround(mins[2]))
		write_coord(floatround(maxs[0]))
		write_coord(floatround(maxs[1]))
		write_coord(floatround(maxs[2]))
		write_short(6)
		write_byte(255)
		write_byte(255)
		write_byte(255)
		message_end()
	}
	
	// Implosion
	message_begin(MSG_BROADCAST,SVC_TEMPENTITY)
	write_byte(14)
	write_coord(floatround(mins[0]+10))
	write_coord(floatround(mins[1]+10))
	write_coord(floatround(mins[2]+10))
	write_byte(radius)
	write_byte(10)
	write_byte(6)
	message_end()
}

// =================================================================================================
// Display current running status
// =================================================================================================
public func_exploit_status(id,level,cid) {
	if(!cmd_access(id,level,cid,1))
		return PLUGIN_HANDLED
		
	format(def_dir,95,"%s/nade_exploits",config_dir)
	format(def_name,127,"%s/%s.edf",def_dir,temp_map_name)
	
	if(status == 1)
	{
		client_print(id,print_console,"[Nade Exploit] Running with definition file: %s",def_name)
		client_print(id,print_console,"[Nade Exploit] There is %i block(s) currently running.",total_blocks + 1)
		client_print(id,print_chat,"[Nade Exploit] Running with definition file: %s",def_name)
		client_print(id,print_chat,"[Nade Exploit] There is %i block(s) currently running.",total_blocks + 1)
	}
	if(status == 2)
	{
		client_print(id,print_console,"[Nade Exploit] There was a problem loading the definition file: %s",def_name)
		client_print(id,print_chat,"[Nade Exploit] There was a problem loading the definition file: %s",def_name)
	}
	return PLUGIN_HANDLED
}
